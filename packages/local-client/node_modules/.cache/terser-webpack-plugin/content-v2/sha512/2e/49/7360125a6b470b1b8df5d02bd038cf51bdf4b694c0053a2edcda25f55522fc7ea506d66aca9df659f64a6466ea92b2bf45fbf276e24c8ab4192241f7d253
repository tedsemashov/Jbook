{"code":"(this[\"webpackJsonpcode-editor\"]=this[\"webpackJsonpcode-editor\"]||[]).push([[84],{254:function(e,t){!function(e){var t=/\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char8_t|char16_t|char32_t|class|compl|concept|const|consteval|constexpr|constinit|const_cast|continue|co_await|co_return|co_yield|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/,n=/\\b(?!<keyword>)\\w+(?:\\s*\\.\\s*\\w+)*\\b/.source.replace(/<keyword>/g,(function(){return t.source}));e.languages.cpp=e.languages.extend(\"c\",{\"class-name\":[{pattern:RegExp(/(\\b(?:class|concept|enum|struct|typename)\\s+)(?!<keyword>)\\w+/.source.replace(/<keyword>/g,(function(){return t.source}))),lookbehind:!0},/\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/,/\\b[A-Z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i,/\\b\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/],keyword:t,number:{pattern:/(?:\\b0b[01']+|\\b0x(?:[\\da-f']+(?:\\.[\\da-f']*)?|\\.[\\da-f']+)(?:p[+-]?[\\d']+)?|(?:\\b[\\d']+(?:\\.[\\d']*)?|\\B\\.[\\d']+)(?:e[+-]?[\\d']+)?)[ful]{0,4}/i,greedy:!0},operator:/>>=?|<<=?|->|--|\\+\\+|&&|\\|\\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/,boolean:/\\b(?:true|false)\\b/}),e.languages.insertBefore(\"cpp\",\"string\",{module:{pattern:RegExp(/(\\b(?:module|import)\\s+)/.source+\"(?:\"+/\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|<[^<>\\r\\n]*>/.source+\"|\"+/<mod-name>(?:\\s*:\\s*<mod-name>)?|:\\s*<mod-name>/.source.replace(/<mod-name>/g,(function(){return n}))+\")\"),lookbehind:!0,greedy:!0,inside:{string:/^[<\"][\\s\\S]+/,operator:/:/,punctuation:/\\./}},\"raw-string\":{pattern:/R\"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1\"/,alias:\"string\",greedy:!0}}),e.languages.insertBefore(\"cpp\",\"keyword\",{\"generic-function\":{pattern:/\\b[a-z_]\\w*\\s*<(?:[^<>]|<(?:[^<>])*>)*>(?=\\s*\\()/i,inside:{function:/^\\w+/,generic:{pattern:/<[\\s\\S]+/,alias:\"class-name\",inside:e.languages.cpp}}}}),e.languages.insertBefore(\"cpp\",\"operator\",{\"double-colon\":{pattern:/::/,alias:\"punctuation\"}}),e.languages.insertBefore(\"cpp\",\"class-name\",{\"base-clause\":{pattern:/(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)[^;{}\"'\\s]+(?:\\s+[^;{}\"'\\s]+)*(?=\\s*[;{])/,lookbehind:!0,greedy:!0,inside:e.languages.extend(\"cpp\",{})}}),e.languages.insertBefore(\"inside\",\"double-colon\",{\"class-name\":/\\b[a-z_]\\w*\\b(?!\\s*::)/i},e.languages.cpp[\"base-clause\"])}(Prism)}}]);","name":"static/js/84.dadb9e86.chunk.js","map":{"version":3,"sources":["static/js/84.dadb9e86.chunk.js"],"names":["this","push","module","exports","Prism","keyword","modName","source","replace","languages","cpp","extend","pattern","RegExp","lookbehind","number","greedy","operator","boolean","insertBefore","inside","string","punctuation","alias","function","generic"],"mappings":"CAACA,KAAK,2BAA6BA,KAAK,4BAA8B,IAAIC,KAAK,CAAC,CAAC,IAAI,CAE/E,IACA,SAAUC,EAAQC,IAExB,SAAWC,GACT,IAAIC,EAAU,osBACVC,EAAU,uCAAuCC,OAAOC,QAAQ,cAAc,WAChF,OAAOH,EAAQE,UAEjBH,EAAMK,UAAUC,IAAMN,EAAMK,UAAUE,OAAO,IAAK,CAChD,aAAc,CAAC,CACbC,QAASC,OAAO,gEAAgEN,OAAOC,QAAQ,cAAc,WAC3G,OAAOH,EAAQE,WAEjBO,YAAY,GAKd,iCAEA,oCAEA,kEACAT,QAAWA,EACXU,OAAU,CACRH,QAAS,iJACTI,QAAQ,GAEVC,SAAY,yHACZC,QAAW,uBAEbd,EAAMK,UAAUU,aAAa,MAAO,SAAU,CAC5CjB,OAAU,CAERU,QAASC,OAAO,2BAA2BN,OAAS,MACpD,mDAAmDA,OAAS,IAC5D,kDAAkDA,OAAOC,QAAQ,eAAe,WAC9E,OAAOF,KACJ,KACLQ,YAAY,EACZE,QAAQ,EACRI,OAAQ,CACNC,OAAU,eACVJ,SAAY,IACZK,YAAe,OAGnB,aAAc,CACZV,QAAS,oCACTW,MAAO,SACPP,QAAQ,KAGZZ,EAAMK,UAAUU,aAAa,MAAO,UAAW,CAC7C,mBAAoB,CAClBP,QAAS,oDACTQ,OAAQ,CACNI,SAAY,OACZC,QAAW,CACTb,QAAS,WACTW,MAAO,aACPH,OAAQhB,EAAMK,UAAUC,SAKhCN,EAAMK,UAAUU,aAAa,MAAO,WAAY,CAC9C,eAAgB,CACdP,QAAS,KACTW,MAAO,iBAGXnB,EAAMK,UAAUU,aAAa,MAAO,aAAc,CAGhD,cAAe,CACbP,QAAS,6EACTE,YAAY,EACZE,QAAQ,EACRI,OAAQhB,EAAMK,UAAUE,OAAO,MAAO,OAG1CP,EAAMK,UAAUU,aAAa,SAAU,eAAgB,CAErD,aAAc,2BACbf,EAAMK,UAAUC,IAAI,gBAlFzB,CAmFGN"},"input":"(this[\"webpackJsonpcode-editor\"] = this[\"webpackJsonpcode-editor\"] || []).push([[84],{\n\n/***/ 254:\n/***/ (function(module, exports) {\n\n(function (Prism) {\n  var keyword = /\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char8_t|char16_t|char32_t|class|compl|concept|const|consteval|constexpr|constinit|const_cast|continue|co_await|co_return|co_yield|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/;\n  var modName = /\\b(?!<keyword>)\\w+(?:\\s*\\.\\s*\\w+)*\\b/.source.replace(/<keyword>/g, function () {\n    return keyword.source;\n  });\n  Prism.languages.cpp = Prism.languages.extend('c', {\n    'class-name': [{\n      pattern: RegExp(/(\\b(?:class|concept|enum|struct|typename)\\s+)(?!<keyword>)\\w+/.source.replace(/<keyword>/g, function () {\n        return keyword.source;\n      })),\n      lookbehind: true\n    }, // This is intended to capture the class name of method implementations like:\n    //   void foo::bar() const {}\n    // However! The `foo` in the above example could also be a namespace, so we only capture the class name if\n    // it starts with an uppercase letter. This approximation should give decent results.\n    /\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/, // This will capture the class name before destructors like:\n    //   Foo::~Foo() {}\n    /\\b[A-Z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i, // This also intends to capture the class name of method implementations but here the class has template\n    // parameters, so it can't be a namespace (until C++ adds generic namespaces).\n    /\\b\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/],\n    'keyword': keyword,\n    'number': {\n      pattern: /(?:\\b0b[01']+|\\b0x(?:[\\da-f']+(?:\\.[\\da-f']*)?|\\.[\\da-f']+)(?:p[+-]?[\\d']+)?|(?:\\b[\\d']+(?:\\.[\\d']*)?|\\B\\.[\\d']+)(?:e[+-]?[\\d']+)?)[ful]{0,4}/i,\n      greedy: true\n    },\n    'operator': />>=?|<<=?|->|--|\\+\\+|&&|\\|\\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/,\n    'boolean': /\\b(?:true|false)\\b/\n  });\n  Prism.languages.insertBefore('cpp', 'string', {\n    'module': {\n      // https://en.cppreference.com/w/cpp/language/modules\n      pattern: RegExp(/(\\b(?:module|import)\\s+)/.source + '(?:' + // header-name\n      /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|<[^<>\\r\\n]*>/.source + '|' + // module name or partition or both\n      /<mod-name>(?:\\s*:\\s*<mod-name>)?|:\\s*<mod-name>/.source.replace(/<mod-name>/g, function () {\n        return modName;\n      }) + ')'),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'string': /^[<\"][\\s\\S]+/,\n        'operator': /:/,\n        'punctuation': /\\./\n      }\n    },\n    'raw-string': {\n      pattern: /R\"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1\"/,\n      alias: 'string',\n      greedy: true\n    }\n  });\n  Prism.languages.insertBefore('cpp', 'keyword', {\n    'generic-function': {\n      pattern: /\\b[a-z_]\\w*\\s*<(?:[^<>]|<(?:[^<>])*>)*>(?=\\s*\\()/i,\n      inside: {\n        'function': /^\\w+/,\n        'generic': {\n          pattern: /<[\\s\\S]+/,\n          alias: 'class-name',\n          inside: Prism.languages.cpp\n        }\n      }\n    }\n  });\n  Prism.languages.insertBefore('cpp', 'operator', {\n    'double-colon': {\n      pattern: /::/,\n      alias: 'punctuation'\n    }\n  });\n  Prism.languages.insertBefore('cpp', 'class-name', {\n    // the base clause is an optional list of parent classes\n    // https://en.cppreference.com/w/cpp/language/class\n    'base-clause': {\n      pattern: /(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)[^;{}\"'\\s]+(?:\\s+[^;{}\"'\\s]+)*(?=\\s*[;{])/,\n      lookbehind: true,\n      greedy: true,\n      inside: Prism.languages.extend('cpp', {})\n    }\n  });\n  Prism.languages.insertBefore('inside', 'double-colon', {\n    // All untokenized words that are not namespaces should be class names\n    'class-name': /\\b[a-z_]\\w*\\b(?!\\s*::)/i\n  }, Prism.languages.cpp['base-clause']);\n})(Prism);\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["/Users/ted/Desktop/jbook/packages/local-client/node_modules/prismjs/components/prism-cpp.js"],"names":["Prism","keyword","modName","source","replace","languages","cpp","extend","pattern","RegExp","lookbehind","greedy","insertBefore","inside","alias"],"mappings":";;;;;AAAC,WAAUA,KAAV,EAAiB;AAEjB,MAAIC,OAAO,GAAG,msBAAd;AACA,MAAIC,OAAO,GAAG,uCAAuCC,MAAvC,CAA8CC,OAA9C,CAAsD,YAAtD,EAAoE,YAAY;AAAE,WAAOH,OAAO,CAACE,MAAf;AAAwB,GAA1G,CAAd;AAEAH,OAAK,CAACK,SAAN,CAAgBC,GAAhB,GAAsBN,KAAK,CAACK,SAAN,CAAgBE,MAAhB,CAAuB,GAAvB,EAA4B;AACjD,kBAAc,CACb;AACCC,aAAO,EAAEC,MAAM,CAAC,gEAAgEN,MAAhE,CACdC,OADc,CACN,YADM,EACQ,YAAY;AAAE,eAAOH,OAAO,CAACE,MAAf;AAAwB,OAD9C,CAAD,CADhB;AAGCO,gBAAU,EAAE;AAHb,KADa,EAMb;AACA;AACA;AACA;AACA,oCAVa,EAWb;AACA;AACA,uCAba,EAcb;AACA;AACA,oEAhBa,CADmC;AAmBjD,eAAWT,OAnBsC;AAoBjD,cAAU;AACTO,aAAO,EAAE,gJADA;AAETG,YAAM,EAAE;AAFC,KApBuC;AAwBjD,gBAAY,wHAxBqC;AAyBjD,eAAW;AAzBsC,GAA5B,CAAtB;AA4BAX,OAAK,CAACK,SAAN,CAAgBO,YAAhB,CAA6B,KAA7B,EAAoC,QAApC,EAA8C;AAC7C,cAAU;AACT;AACAJ,aAAO,EAAEC,MAAM,CACd,2BAA2BN,MAA3B,GACA,KADA,GAEA;AACA,yDAAmDA,MAHnD,GAIA,GAJA,GAKA;AACA,wDAAkDA,MAAlD,CAAyDC,OAAzD,CAAiE,aAAjE,EAAgF,YAAY;AAAE,eAAOF,OAAP;AAAiB,OAA/G,CANA,GAOA,GARc,CAFN;AAYTQ,gBAAU,EAAE,IAZH;AAaTC,YAAM,EAAE,IAbC;AAcTE,YAAM,EAAE;AACP,kBAAU,cADH;AAEP,oBAAY,GAFL;AAGP,uBAAe;AAHR;AAdC,KADmC;AAqB7C,kBAAc;AACbL,aAAO,EAAE,mCADI;AAEbM,WAAK,EAAE,QAFM;AAGbH,YAAM,EAAE;AAHK;AArB+B,GAA9C;AA4BAX,OAAK,CAACK,SAAN,CAAgBO,YAAhB,CAA6B,KAA7B,EAAoC,SAApC,EAA+C;AAC9C,wBAAoB;AACnBJ,aAAO,EAAE,mDADU;AAEnBK,YAAM,EAAE;AACP,oBAAY,MADL;AAEP,mBAAW;AACVL,iBAAO,EAAE,UADC;AAEVM,eAAK,EAAE,YAFG;AAGVD,gBAAM,EAAEb,KAAK,CAACK,SAAN,CAAgBC;AAHd;AAFJ;AAFW;AAD0B,GAA/C;AAcAN,OAAK,CAACK,SAAN,CAAgBO,YAAhB,CAA6B,KAA7B,EAAoC,UAApC,EAAgD;AAC/C,oBAAgB;AACfJ,aAAO,EAAE,IADM;AAEfM,WAAK,EAAE;AAFQ;AAD+B,GAAhD;AAOAd,OAAK,CAACK,SAAN,CAAgBO,YAAhB,CAA6B,KAA7B,EAAoC,YAApC,EAAkD;AACjD;AACA;AACA,mBAAe;AACdJ,aAAO,EAAE,4EADK;AAEdE,gBAAU,EAAE,IAFE;AAGdC,YAAM,EAAE,IAHM;AAIdE,YAAM,EAAEb,KAAK,CAACK,SAAN,CAAgBE,MAAhB,CAAuB,KAAvB,EAA8B,EAA9B;AAJM;AAHkC,GAAlD;AAWAP,OAAK,CAACK,SAAN,CAAgBO,YAAhB,CAA6B,QAA7B,EAAuC,cAAvC,EAAuD;AACtD;AACA,kBAAc;AAFwC,GAAvD,EAGGZ,KAAK,CAACK,SAAN,CAAgBC,GAAhB,CAAoB,aAApB,CAHH;AAKA,CAlGA,EAkGCN,KAlGD,CAAD,C","file":"x","sourcesContent":["(function (Prism) {\n\n\tvar keyword = /\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char8_t|char16_t|char32_t|class|compl|concept|const|consteval|constexpr|constinit|const_cast|continue|co_await|co_return|co_yield|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/;\n\tvar modName = /\\b(?!<keyword>)\\w+(?:\\s*\\.\\s*\\w+)*\\b/.source.replace(/<keyword>/g, function () { return keyword.source; });\n\n\tPrism.languages.cpp = Prism.languages.extend('c', {\n\t\t'class-name': [\n\t\t\t{\n\t\t\t\tpattern: RegExp(/(\\b(?:class|concept|enum|struct|typename)\\s+)(?!<keyword>)\\w+/.source\n\t\t\t\t\t.replace(/<keyword>/g, function () { return keyword.source; })),\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t// This is intended to capture the class name of method implementations like:\n\t\t\t//   void foo::bar() const {}\n\t\t\t// However! The `foo` in the above example could also be a namespace, so we only capture the class name if\n\t\t\t// it starts with an uppercase letter. This approximation should give decent results.\n\t\t\t/\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/,\n\t\t\t// This will capture the class name before destructors like:\n\t\t\t//   Foo::~Foo() {}\n\t\t\t/\\b[A-Z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i,\n\t\t\t// This also intends to capture the class name of method implementations but here the class has template\n\t\t\t// parameters, so it can't be a namespace (until C++ adds generic namespaces).\n\t\t\t/\\b\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/\n\t\t],\n\t\t'keyword': keyword,\n\t\t'number': {\n\t\t\tpattern: /(?:\\b0b[01']+|\\b0x(?:[\\da-f']+(?:\\.[\\da-f']*)?|\\.[\\da-f']+)(?:p[+-]?[\\d']+)?|(?:\\b[\\d']+(?:\\.[\\d']*)?|\\B\\.[\\d']+)(?:e[+-]?[\\d']+)?)[ful]{0,4}/i,\n\t\t\tgreedy: true\n\t\t},\n\t\t'operator': />>=?|<<=?|->|--|\\+\\+|&&|\\|\\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/,\n\t\t'boolean': /\\b(?:true|false)\\b/\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'string', {\n\t\t'module': {\n\t\t\t// https://en.cppreference.com/w/cpp/language/modules\n\t\t\tpattern: RegExp(\n\t\t\t\t/(\\b(?:module|import)\\s+)/.source +\n\t\t\t\t'(?:' +\n\t\t\t\t// header-name\n\t\t\t\t/\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|<[^<>\\r\\n]*>/.source +\n\t\t\t\t'|' +\n\t\t\t\t// module name or partition or both\n\t\t\t\t/<mod-name>(?:\\s*:\\s*<mod-name>)?|:\\s*<mod-name>/.source.replace(/<mod-name>/g, function () { return modName; }) +\n\t\t\t\t')'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'string': /^[<\"][\\s\\S]+/,\n\t\t\t\t'operator': /:/,\n\t\t\t\t'punctuation': /\\./\n\t\t\t}\n\t\t},\n\t\t'raw-string': {\n\t\t\tpattern: /R\"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1\"/,\n\t\t\talias: 'string',\n\t\t\tgreedy: true\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'keyword', {\n\t\t'generic-function': {\n\t\t\tpattern: /\\b[a-z_]\\w*\\s*<(?:[^<>]|<(?:[^<>])*>)*>(?=\\s*\\()/i,\n\t\t\tinside: {\n\t\t\t\t'function': /^\\w+/,\n\t\t\t\t'generic': {\n\t\t\t\t\tpattern: /<[\\s\\S]+/,\n\t\t\t\t\talias: 'class-name',\n\t\t\t\t\tinside: Prism.languages.cpp\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'operator', {\n\t\t'double-colon': {\n\t\t\tpattern: /::/,\n\t\t\talias: 'punctuation'\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'class-name', {\n\t\t// the base clause is an optional list of parent classes\n\t\t// https://en.cppreference.com/w/cpp/language/class\n\t\t'base-clause': {\n\t\t\tpattern: /(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)[^;{}\"'\\s]+(?:\\s+[^;{}\"'\\s]+)*(?=\\s*[;{])/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: Prism.languages.extend('cpp', {})\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('inside', 'double-colon', {\n\t\t// All untokenized words that are not namespaces should be class names\n\t\t'class-name': /\\b[a-z_]\\w*\\b(?!\\s*::)/i\n\t}, Prism.languages.cpp['base-clause']);\n\n}(Prism));\n"]}}