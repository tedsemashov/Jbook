{"code":"(this[\"webpackJsonpcode-editor\"]=this[\"webpackJsonpcode-editor\"]||[]).push([[250],{420:function(n,o){!function(n){var o=/\\s\\x00-\\x1f\\x22-\\x2f\\x3a-\\x3f\\x5b-\\x5e\\x60\\x7b-\\x7e/.source;function e(n,e){return RegExp(n.replace(/<nonId>/g,o),e)}n.languages.kumir={comment:{pattern:/\\|.*/},prolog:{pattern:/#.*/,greedy:!0},string:{pattern:/\"[^\\n\\r\"]*\"|'[^\\n\\r']*'/,greedy:!0},boolean:{pattern:e(/(^|[<nonId>])(?:\\u0434\\u0430|\\u043d\\u0435\\u0442)(?=[<nonId>]|$)/.source),lookbehind:!0},\"operator-word\":{pattern:e(/(^|[<nonId>])(?:\\u0438|\\u0438\\u043b\\u0438|\\u043d\\u0435)(?=[<nonId>]|$)/.source),lookbehind:!0,alias:\"keyword\"},\"system-variable\":{pattern:e(/(^|[<nonId>])\\u0437\\u043d\\u0430\\u0447(?=[<nonId>]|$)/.source),lookbehind:!0,alias:\"keyword\"},type:[{pattern:e(/(^|[<nonId>])(?:\\u0432\\u0435\\u0449|\\u043b\\u0438\\u0442|\\u043b\\u043e\\u0433|\\u0441\\u0438\\u043c|\\u0446\\u0435\\u043b)(?:\\x20*\\u0442\\u0430\\u0431)?(?=[<nonId>]|$)/.source),lookbehind:!0,alias:\"builtin\"},{pattern:e(/(^|[<nonId>])(?:\\u043a\\u043e\\u043c\\u043f\\u043b|\\u0441\\u043a\\u0430\\u043d\\u043a\\u043e\\u0434|\\u0444\\u0430\\u0439\\u043b|\\u0446\\u0432\\u0435\\u0442)(?=[<nonId>]|$)/.source),lookbehind:!0,alias:\"important\"}],keyword:{pattern:e(/(^|[<nonId>])(?:\\u0430\\u043b\\u0433|\\u0430\\u0440\\u0433(?:\\x20*\\u0440\\u0435\\u0437)?|\\u0432\\u0432\\u043e\\u0434|\\u0412\\u041a\\u041b\\u042e\\u0427\\u0418\\u0422\\u042c|\\u0432\\u0441[\\u0435\\u0451]|\\u0432\\u044b\\u0431\\u043e\\u0440|\\u0432\\u044b\\u0432\\u043e\\u0434|\\u0432\\u044b\\u0445\\u043e\\u0434|\\u0434\\u0430\\u043d\\u043e|\\u0434\\u043b\\u044f|\\u0434\\u043e|\\u0434\\u0441|\\u0435\\u0441\\u043b\\u0438|\\u0438\\u043d\\u0430\\u0447\\u0435|\\u0438\\u0441\\u043f|\\u0438\\u0441\\u043f\\u043e\\u043b\\u044c\\u0437\\u043e\\u0432\\u0430\\u0442\\u044c|\\u043a\\u043e\\u043d(?:(?:\\x20+|_)\\u0438\\u0441\\u043f)?|\\u043a\\u0446(?:(?:\\x20+|_)\\u043f\\u0440\\u0438)?|\\u043d\\u0430\\u0434\\u043e|\\u043d\\u0430\\u0447|\\u043d\\u0441|\\u043d\\u0446|\\u043e\\u0442|\\u043f\\u0430\\u0443\\u0437\\u0430|\\u043f\\u043e\\u043a\\u0430|\\u043f\\u0440\\u0438|\\u0440\\u0430\\u0437\\u0430?|\\u0440\\u0435\\u0437|\\u0441\\u0442\\u043e\\u043f|\\u0442\\u0430\\u0431|\\u0442\\u043e|\\u0443\\u0442\\u0432|\\u0448\\u0430\\u0433)(?=[<nonId>]|$)/.source),lookbehind:!0},name:{pattern:e(/(^|[<nonId>])[^\\d<nonId>][^<nonId>]*(?:\\x20+[^<nonId>]+)*(?=[<nonId>]|$)/.source),lookbehind:!0},number:{pattern:e(/(^|[<nonId>])(?:\\B\\$[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)(?=[<nonId>]|$)/.source,\"i\"),lookbehind:!0},punctuation:/:=|[(),:;\\[\\]]/,\"operator-char\":{pattern:/\\*\\*?|<[=>]?|>=?|[-+/=]/,alias:\"operator\"}},n.languages.kum=n.languages.kumir}(Prism)}}]);","name":"static/js/250.4a0de8f2.chunk.js","map":{"version":3,"sources":["static/js/250.4a0de8f2.chunk.js"],"names":["this","push","module","exports","Prism","nonId","source","wrapId","pattern","flags","RegExp","replace","languages","kumir","comment","prolog","greedy","string","boolean","lookbehind","alias","type","keyword","name","number","punctuation","kum"],"mappings":"CAACA,KAAK,2BAA6BA,KAAK,4BAA8B,IAAIC,KAAK,CAAC,CAAC,KAAK,CAEhF,IACA,SAAUC,EAAQC,IAGxB,SAAWC,GAMT,IAAIC,EAAQ,sDAAsDC,OASlE,SAASC,EAAOC,EAASC,GACvB,OAAOC,OAAOF,EAAQG,QAAQ,WAAYN,GAAQI,GAGpDL,EAAMQ,UAAUC,MAAQ,CACtBC,QAAW,CACTN,QAAS,QAEXO,OAAU,CACRP,QAAS,MACTQ,QAAQ,GAEVC,OAAU,CACRT,QAAS,0BACTQ,QAAQ,GAEVE,QAAW,CACTV,QAASD,EAAO,kEAAyCD,QACzDa,YAAY,GAEd,gBAAiB,CACfX,QAASD,EAAO,yEAA2CD,QAC3Da,YAAY,EACZC,MAAO,WAET,kBAAmB,CACjBZ,QAASD,EAAO,uDAAmCD,QACnDa,YAAY,EACZC,MAAO,WAETC,KAAQ,CAAC,CACPb,QAASD,EAAO,6JAAmED,QACnFa,YAAY,EACZC,MAAO,WACN,CACDZ,QAASD,EAAO,8JAA0DD,QAC1Ea,YAAY,EACZC,MAAO,cAQTE,QAAW,CACTd,QAASD,EAAO,84BAAqPD,QACrQa,YAAY,GAIdI,KAAQ,CACNf,QAASD,EAAO,2EAA2ED,QAC3Fa,YAAY,GAIdK,OAAU,CACRhB,QAASD,EAAO,2FAA2FD,OAAQ,KACnHa,YAAY,GAIdM,YAAe,iBAOf,gBAAiB,CACfjB,QAAS,0BACTY,MAAO,aAGXhB,EAAMQ,UAAUc,IAAMtB,EAAMQ,UAAUC,MA1FxC,CA2FGT"},"input":"(this[\"webpackJsonpcode-editor\"] = this[\"webpackJsonpcode-editor\"] || []).push([[250],{\n\n/***/ 420:\n/***/ (function(module, exports) {\n\n/* eslint-disable regexp/no-dupe-characters-character-class */\n(function (Prism) {\n  /**\n   * Regular expression for characters that are not allowed in identifiers.\n   *\n   * @type {string}\n   */\n  var nonId = /\\s\\x00-\\x1f\\x22-\\x2f\\x3a-\\x3f\\x5b-\\x5e\\x60\\x7b-\\x7e/.source;\n  /**\n   * Surround a regular expression for IDs with patterns for non-ID sequences.\n   *\n   * @param {string} pattern A regular expression for identifiers.\n   * @param {string} [flags] The regular expression flags.\n   * @returns {RegExp} A wrapped regular expression for identifiers.\n   */\n\n  function wrapId(pattern, flags) {\n    return RegExp(pattern.replace(/<nonId>/g, nonId), flags);\n  }\n\n  Prism.languages.kumir = {\n    'comment': {\n      pattern: /\\|.*/\n    },\n    'prolog': {\n      pattern: /#.*/,\n      greedy: true\n    },\n    'string': {\n      pattern: /\"[^\\n\\r\"]*\"|'[^\\n\\r']*'/,\n      greedy: true\n    },\n    'boolean': {\n      pattern: wrapId(/(^|[<nonId>])(?:да|нет)(?=[<nonId>]|$)/.source),\n      lookbehind: true\n    },\n    'operator-word': {\n      pattern: wrapId(/(^|[<nonId>])(?:и|или|не)(?=[<nonId>]|$)/.source),\n      lookbehind: true,\n      alias: 'keyword'\n    },\n    'system-variable': {\n      pattern: wrapId(/(^|[<nonId>])знач(?=[<nonId>]|$)/.source),\n      lookbehind: true,\n      alias: 'keyword'\n    },\n    'type': [{\n      pattern: wrapId(/(^|[<nonId>])(?:вещ|лит|лог|сим|цел)(?:\\x20*таб)?(?=[<nonId>]|$)/.source),\n      lookbehind: true,\n      alias: 'builtin'\n    }, {\n      pattern: wrapId(/(^|[<nonId>])(?:компл|сканкод|файл|цвет)(?=[<nonId>]|$)/.source),\n      lookbehind: true,\n      alias: 'important'\n    }],\n\n    /**\n     * Should be performed after searching for type names because of \"таб\".\n     * \"таб\" is a reserved word, but never used without a preceding type name.\n     * \"НАЗНАЧИТЬ\", \"Фввод\", and \"Фвывод\" are not reserved words.\n     */\n    'keyword': {\n      pattern: wrapId(/(^|[<nonId>])(?:алг|арг(?:\\x20*рез)?|ввод|ВКЛЮЧИТЬ|вс[её]|выбор|вывод|выход|дано|для|до|дс|если|иначе|исп|использовать|кон(?:(?:\\x20+|_)исп)?|кц(?:(?:\\x20+|_)при)?|надо|нач|нс|нц|от|пауза|пока|при|раза?|рез|стоп|таб|то|утв|шаг)(?=[<nonId>]|$)/.source),\n      lookbehind: true\n    },\n\n    /** Should be performed after searching for reserved words. */\n    'name': {\n      pattern: wrapId(/(^|[<nonId>])[^\\d<nonId>][^<nonId>]*(?:\\x20+[^<nonId>]+)*(?=[<nonId>]|$)/.source),\n      lookbehind: true\n    },\n\n    /** Should be performed after searching for names. */\n    'number': {\n      pattern: wrapId(/(^|[<nonId>])(?:\\B\\$[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)(?=[<nonId>]|$)/.source, 'i'),\n      lookbehind: true\n    },\n\n    /** Should be performed after searching for words. */\n    'punctuation': /:=|[(),:;\\[\\]]/,\n\n    /**\n     * Should be performed after searching for\n     * - numeric constants (because of \"+\" and \"-\");\n     * - punctuation marks (because of \":=\" and \"=\").\n     */\n    'operator-char': {\n      pattern: /\\*\\*?|<[=>]?|>=?|[-+/=]/,\n      alias: 'operator'\n    }\n  };\n  Prism.languages.kum = Prism.languages.kumir;\n})(Prism);\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["/Users/ted/Desktop/jbook/packages/local-client/node_modules/prismjs/components/prism-kumir.js"],"names":["Prism","nonId","source","wrapId","pattern","flags","RegExp","replace","languages","kumir","greedy","lookbehind","alias","kum"],"mappings":";;;;;AAAA;AACC,WAAUA,KAAV,EAAiB;AAEjB;AACD;AACA;AACA;AACA;AACC,MAAIC,KAAK,GAAG,sDAAsDC,MAAlE;AAEA;AACD;AACA;AACA;AACA;AACA;AACA;;AACC,WAASC,MAAT,CAAgBC,OAAhB,EAAyBC,KAAzB,EAAgC;AAC/B,WAAOC,MAAM,CAACF,OAAO,CAACG,OAAR,CAAgB,UAAhB,EAA4BN,KAA5B,CAAD,EAAqCI,KAArC,CAAb;AACA;;AAEDL,OAAK,CAACQ,SAAN,CAAgBC,KAAhB,GAAwB;AACvB,eAAW;AACVL,aAAO,EAAE;AADC,KADY;AAKvB,cAAU;AACTA,aAAO,EAAE,KADA;AAETM,YAAM,EAAE;AAFC,KALa;AAUvB,cAAU;AACTN,aAAO,EAAE,yBADA;AAETM,YAAM,EAAE;AAFC,KAVa;AAevB,eAAW;AACVN,aAAO,EAAED,MAAM,CAAC,yCAAyCD,MAA1C,CADL;AAEVS,gBAAU,EAAE;AAFF,KAfY;AAoBvB,qBAAiB;AAChBP,aAAO,EAAED,MAAM,CAAC,2CAA2CD,MAA5C,CADC;AAEhBS,gBAAU,EAAE,IAFI;AAGhBC,WAAK,EAAE;AAHS,KApBM;AA0BvB,uBAAmB;AAClBR,aAAO,EAAED,MAAM,CAAC,mCAAmCD,MAApC,CADG;AAElBS,gBAAU,EAAE,IAFM;AAGlBC,WAAK,EAAE;AAHW,KA1BI;AAgCvB,YAAQ,CACP;AACCR,aAAO,EAAED,MAAM,CAAC,mEAAmED,MAApE,CADhB;AAECS,gBAAU,EAAE,IAFb;AAGCC,WAAK,EAAE;AAHR,KADO,EAMP;AACCR,aAAO,EAAED,MAAM,CAAC,0DAA0DD,MAA3D,CADhB;AAECS,gBAAU,EAAE,IAFb;AAGCC,WAAK,EAAE;AAHR,KANO,CAhCe;;AA6CvB;AACF;AACA;AACA;AACA;AACE,eAAW;AACVR,aAAO,EAAED,MAAM,CAAC,qPAAqPD,MAAtP,CADL;AAEVS,gBAAU,EAAE;AAFF,KAlDY;;AAuDvB;AACA,YAAQ;AACPP,aAAO,EAAED,MAAM,CAAC,2EAA2ED,MAA5E,CADR;AAEPS,gBAAU,EAAE;AAFL,KAxDe;;AA6DvB;AACA,cAAU;AACTP,aAAO,EAAED,MAAM,CAAC,2FAA2FD,MAA5F,EAAoG,GAApG,CADN;AAETS,gBAAU,EAAE;AAFH,KA9Da;;AAmEvB;AACA,mBAAe,gBApEQ;;AAsEvB;AACF;AACA;AACA;AACA;AACE,qBAAiB;AAChBP,aAAO,EAAE,yBADO;AAEhBQ,WAAK,EAAE;AAFS;AA3EM,GAAxB;AAiFAZ,OAAK,CAACQ,SAAN,CAAgBK,GAAhB,GAAsBb,KAAK,CAACQ,SAAN,CAAgBC,KAAtC;AAEA,CAvGA,EAuGCT,KAvGD,CAAD,C","file":"x","sourcesContent":["/* eslint-disable regexp/no-dupe-characters-character-class */\n(function (Prism) {\n\n\t/**\n\t * Regular expression for characters that are not allowed in identifiers.\n\t *\n\t * @type {string}\n\t */\n\tvar nonId = /\\s\\x00-\\x1f\\x22-\\x2f\\x3a-\\x3f\\x5b-\\x5e\\x60\\x7b-\\x7e/.source;\n\n\t/**\n\t * Surround a regular expression for IDs with patterns for non-ID sequences.\n\t *\n\t * @param {string} pattern A regular expression for identifiers.\n\t * @param {string} [flags] The regular expression flags.\n\t * @returns {RegExp} A wrapped regular expression for identifiers.\n\t */\n\tfunction wrapId(pattern, flags) {\n\t\treturn RegExp(pattern.replace(/<nonId>/g, nonId), flags);\n\t}\n\n\tPrism.languages.kumir = {\n\t\t'comment': {\n\t\t\tpattern: /\\|.*/\n\t\t},\n\n\t\t'prolog': {\n\t\t\tpattern: /#.*/,\n\t\t\tgreedy: true\n\t\t},\n\n\t\t'string': {\n\t\t\tpattern: /\"[^\\n\\r\"]*\"|'[^\\n\\r']*'/,\n\t\t\tgreedy: true\n\t\t},\n\n\t\t'boolean': {\n\t\t\tpattern: wrapId(/(^|[<nonId>])(?:да|нет)(?=[<nonId>]|$)/.source),\n\t\t\tlookbehind: true\n\t\t},\n\n\t\t'operator-word': {\n\t\t\tpattern: wrapId(/(^|[<nonId>])(?:и|или|не)(?=[<nonId>]|$)/.source),\n\t\t\tlookbehind: true,\n\t\t\talias: 'keyword'\n\t\t},\n\n\t\t'system-variable': {\n\t\t\tpattern: wrapId(/(^|[<nonId>])знач(?=[<nonId>]|$)/.source),\n\t\t\tlookbehind: true,\n\t\t\talias: 'keyword'\n\t\t},\n\n\t\t'type': [\n\t\t\t{\n\t\t\t\tpattern: wrapId(/(^|[<nonId>])(?:вещ|лит|лог|сим|цел)(?:\\x20*таб)?(?=[<nonId>]|$)/.source),\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'builtin'\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: wrapId(/(^|[<nonId>])(?:компл|сканкод|файл|цвет)(?=[<nonId>]|$)/.source),\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'important'\n\t\t\t}\n\t\t],\n\n\t\t/**\n\t\t * Should be performed after searching for type names because of \"таб\".\n\t\t * \"таб\" is a reserved word, but never used without a preceding type name.\n\t\t * \"НАЗНАЧИТЬ\", \"Фввод\", and \"Фвывод\" are not reserved words.\n\t\t */\n\t\t'keyword': {\n\t\t\tpattern: wrapId(/(^|[<nonId>])(?:алг|арг(?:\\x20*рез)?|ввод|ВКЛЮЧИТЬ|вс[её]|выбор|вывод|выход|дано|для|до|дс|если|иначе|исп|использовать|кон(?:(?:\\x20+|_)исп)?|кц(?:(?:\\x20+|_)при)?|надо|нач|нс|нц|от|пауза|пока|при|раза?|рез|стоп|таб|то|утв|шаг)(?=[<nonId>]|$)/.source),\n\t\t\tlookbehind: true\n\t\t},\n\n\t\t/** Should be performed after searching for reserved words. */\n\t\t'name': {\n\t\t\tpattern: wrapId(/(^|[<nonId>])[^\\d<nonId>][^<nonId>]*(?:\\x20+[^<nonId>]+)*(?=[<nonId>]|$)/.source),\n\t\t\tlookbehind: true\n\t\t},\n\n\t\t/** Should be performed after searching for names. */\n\t\t'number': {\n\t\t\tpattern: wrapId(/(^|[<nonId>])(?:\\B\\$[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)(?=[<nonId>]|$)/.source, 'i'),\n\t\t\tlookbehind: true\n\t\t},\n\n\t\t/** Should be performed after searching for words. */\n\t\t'punctuation': /:=|[(),:;\\[\\]]/,\n\n\t\t/**\n\t\t * Should be performed after searching for\n\t\t * - numeric constants (because of \"+\" and \"-\");\n\t\t * - punctuation marks (because of \":=\" and \"=\").\n\t\t */\n\t\t'operator-char': {\n\t\t\tpattern: /\\*\\*?|<[=>]?|>=?|[-+/=]/,\n\t\t\talias: 'operator'\n\t\t}\n\t};\n\n\tPrism.languages.kum = Prism.languages.kumir;\n\n}(Prism));\n"]}}