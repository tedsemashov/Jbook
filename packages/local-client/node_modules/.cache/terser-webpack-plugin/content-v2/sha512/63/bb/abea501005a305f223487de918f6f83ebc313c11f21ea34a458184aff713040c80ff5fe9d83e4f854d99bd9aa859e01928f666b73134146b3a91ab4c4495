{"code":"(this[\"webpackJsonpcode-editor\"]=this[\"webpackJsonpcode-editor\"]||[]).push([[170],{340:function(t,n){Prism.languages.graphql={comment:/#.*/,description:{pattern:/(?:\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")(?=\\s*[a-z_])/i,greedy:!0,alias:\"string\",inside:{\"language-markdown\":{pattern:/(^\"(?:\"\")?)(?!\\1)[\\s\\S]+(?=\\1$)/,lookbehind:!0,inside:Prism.languages.markdown}}},string:{pattern:/\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/,greedy:!0},number:/(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,boolean:/\\b(?:true|false)\\b/,variable:/\\$[a-z_]\\w*/i,directive:{pattern:/@[a-z_]\\w*/i,alias:\"function\"},\"attr-name\":{pattern:/[a-z_]\\w*(?=\\s*(?:\\((?:[^()\"]|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")*\\))?:)/i,greedy:!0},\"atom-input\":{pattern:/[A-Z]\\w*Input(?=!?.*$)/m,alias:\"class-name\"},scalar:/\\b(?:Boolean|Float|ID|Int|String)\\b/,constant:/\\b[A-Z][A-Z_\\d]*\\b/,\"class-name\":{pattern:/(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,lookbehind:!0},fragment:{pattern:/(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))[a-zA-Z_]\\w*/,lookbehind:!0,alias:\"function\"},\"definition-mutation\":{pattern:/(\\bmutation\\s+)[a-zA-Z_]\\w*/,lookbehind:!0,alias:\"function\"},\"definition-query\":{pattern:/(\\bquery\\s+)[a-zA-Z_]\\w*/,lookbehind:!0,alias:\"function\"},keyword:/\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,operator:/[!=|&]|\\.{3}/,\"property-query\":/\\w+(?=\\s*\\()/,object:/\\w+(?=\\s*\\{)/,punctuation:/[!(){}\\[\\]:=,]/,property:/\\w+/},Prism.hooks.add(\"after-tokenize\",(function(t){if(\"graphql\"===t.language)for(var n=t.tokens.filter((function(t){return\"string\"!==typeof t&&\"comment\"!==t.type&&\"scalar\"!==t.type})),e=0;e<n.length;){var a=n[e++];if(\"keyword\"===a.type&&\"mutation\"===a.content){var r=[];if(l([\"definition-mutation\",\"punctuation\"])&&\"(\"===c(1).content){e+=2;var i=f(/^\\($/,/^\\)$/);if(-1===i)continue;for(;e<i;e++){var o=c(0);\"variable\"===o.type&&(b(o,\"variable-input\"),r.push(o.content))}e=i+1}if(l([\"punctuation\",\"property-query\"])&&\"{\"===c(0).content&&(e++,b(c(0),\"property-mutation\"),r.length>0)){var s=f(/^\\{$/,/^\\}$/);if(-1===s)continue;for(var u=e;u<s;u++){var p=n[u];\"variable\"===p.type&&r.indexOf(p.content)>=0&&b(p,\"variable-input\")}}}}function c(t){return n[e+t]}function l(t,n){n=n||0;for(var e=0;e<t.length;e++){var a=c(e+n);if(!a||a.type!==t[e])return!1}return!0}function f(t,a){for(var r=1,i=e;i<n.length;i++){var o=n[i],s=o.content;if(\"punctuation\"===o.type&&\"string\"===typeof s)if(t.test(s))r++;else if(a.test(s)&&0===--r)return i}return-1}function b(t,n){var e=t.alias;e?Array.isArray(e)||(t.alias=e=[e]):t.alias=e=[],e.push(n)}}))}}]);","name":"static/js/170.f8bb755d.chunk.js","map":{"version":3,"sources":["static/js/170.f8bb755d.chunk.js"],"names":["this","push","module","exports","Prism","languages","graphql","comment","description","pattern","greedy","alias","inside","lookbehind","markdown","string","number","boolean","variable","directive","scalar","constant","fragment","keyword","operator","object","punctuation","property","hooks","add","env","language","validTokens","tokens","filter","token","type","currentIndex","length","startToken","content","inputVariables","isTokenType","getToken","definitionEnd","findClosingBracket","t","addAlias","mutationEnd","i","varToken","indexOf","offset","types","open","close","stackHeight","test","aliases","Array","isArray"],"mappings":"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"},"input":"(this[\"webpackJsonpcode-editor\"] = this[\"webpackJsonpcode-editor\"] || []).push([[170],{\n\n/***/ 340:\n/***/ (function(module, exports) {\n\nPrism.languages.graphql = {\n  'comment': /#.*/,\n  'description': {\n    pattern: /(?:\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")(?=\\s*[a-z_])/i,\n    greedy: true,\n    alias: 'string',\n    inside: {\n      'language-markdown': {\n        pattern: /(^\"(?:\"\")?)(?!\\1)[\\s\\S]+(?=\\1$)/,\n        lookbehind: true,\n        inside: Prism.languages.markdown\n      }\n    }\n  },\n  'string': {\n    pattern: /\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/,\n    greedy: true\n  },\n  'number': /(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n  'boolean': /\\b(?:true|false)\\b/,\n  'variable': /\\$[a-z_]\\w*/i,\n  'directive': {\n    pattern: /@[a-z_]\\w*/i,\n    alias: 'function'\n  },\n  'attr-name': {\n    pattern: /[a-z_]\\w*(?=\\s*(?:\\((?:[^()\"]|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")*\\))?:)/i,\n    greedy: true\n  },\n  'atom-input': {\n    pattern: /[A-Z]\\w*Input(?=!?.*$)/m,\n    alias: 'class-name'\n  },\n  'scalar': /\\b(?:Boolean|Float|ID|Int|String)\\b/,\n  'constant': /\\b[A-Z][A-Z_\\d]*\\b/,\n  'class-name': {\n    pattern: /(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,\n    lookbehind: true\n  },\n  'fragment': {\n    pattern: /(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function'\n  },\n  'definition-mutation': {\n    pattern: /(\\bmutation\\s+)[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function'\n  },\n  'definition-query': {\n    pattern: /(\\bquery\\s+)[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function'\n  },\n  'keyword': /\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,\n  'operator': /[!=|&]|\\.{3}/,\n  'property-query': /\\w+(?=\\s*\\()/,\n  'object': /\\w+(?=\\s*\\{)/,\n  'punctuation': /[!(){}\\[\\]:=,]/,\n  'property': /\\w+/\n};\nPrism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {\n  if (env.language !== 'graphql') {\n    return;\n  }\n  /**\n   * get the graphql token stream that we want to customize\n   *\n   * @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n   * @type {Token[]}\n   */\n\n\n  var validTokens = env.tokens.filter(function (token) {\n    return typeof token !== 'string' && token.type !== 'comment' && token.type !== 'scalar';\n  });\n  var currentIndex = 0;\n  /**\n   * Returns whether the token relative to the current index has the given type.\n   *\n   * @param {number} offset\n   * @returns {Token | undefined}\n   */\n\n  function getToken(offset) {\n    return validTokens[currentIndex + offset];\n  }\n  /**\n   * Returns whether the token relative to the current index has the given type.\n   *\n   * @param {readonly string[]} types\n   * @param {number} [offset=0]\n   * @returns {boolean}\n   */\n\n\n  function isTokenType(types, offset) {\n    offset = offset || 0;\n\n    for (var i = 0; i < types.length; i++) {\n      var token = getToken(i + offset);\n\n      if (!token || token.type !== types[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Returns the index of the closing bracket to an opening bracket.\n   *\n   * It is assumed that `token[currentIndex - 1]` is an opening bracket.\n   *\n   * If no closing bracket could be found, `-1` will be returned.\n   *\n   * @param {RegExp} open\n   * @param {RegExp} close\n   * @returns {number}\n   */\n\n\n  function findClosingBracket(open, close) {\n    var stackHeight = 1;\n\n    for (var i = currentIndex; i < validTokens.length; i++) {\n      var token = validTokens[i];\n      var content = token.content;\n\n      if (token.type === 'punctuation' && typeof content === 'string') {\n        if (open.test(content)) {\n          stackHeight++;\n        } else if (close.test(content)) {\n          stackHeight--;\n\n          if (stackHeight === 0) {\n            return i;\n          }\n        }\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Adds an alias to the given token.\n   *\n   * @param {Token} token\n   * @param {string} alias\n   * @returns {void}\n   */\n\n\n  function addAlias(token, alias) {\n    var aliases = token.alias;\n\n    if (!aliases) {\n      token.alias = aliases = [];\n    } else if (!Array.isArray(aliases)) {\n      token.alias = aliases = [aliases];\n    }\n\n    aliases.push(alias);\n  }\n\n  for (; currentIndex < validTokens.length;) {\n    var startToken = validTokens[currentIndex++]; // add special aliases for mutation tokens\n\n    if (startToken.type === 'keyword' && startToken.content === 'mutation') {\n      // any array of the names of all input variables (if any)\n      var inputVariables = [];\n\n      if (isTokenType(['definition-mutation', 'punctuation']) && getToken(1).content === '(') {\n        // definition\n        currentIndex += 2; // skip 'definition-mutation' and 'punctuation'\n\n        var definitionEnd = findClosingBracket(/^\\($/, /^\\)$/);\n\n        if (definitionEnd === -1) {\n          continue;\n        } // find all input variables\n\n\n        for (; currentIndex < definitionEnd; currentIndex++) {\n          var t = getToken(0);\n\n          if (t.type === 'variable') {\n            addAlias(t, 'variable-input');\n            inputVariables.push(t.content);\n          }\n        }\n\n        currentIndex = definitionEnd + 1;\n      }\n\n      if (isTokenType(['punctuation', 'property-query']) && getToken(0).content === '{') {\n        currentIndex++; // skip opening bracket\n\n        addAlias(getToken(0), 'property-mutation');\n\n        if (inputVariables.length > 0) {\n          var mutationEnd = findClosingBracket(/^\\{$/, /^\\}$/);\n\n          if (mutationEnd === -1) {\n            continue;\n          } // give references to input variables a special alias\n\n\n          for (var i = currentIndex; i < mutationEnd; i++) {\n            var varToken = validTokens[i];\n\n            if (varToken.type === 'variable' && inputVariables.indexOf(varToken.content) >= 0) {\n              addAlias(varToken, 'variable-input');\n            }\n          }\n        }\n      }\n    }\n  }\n});\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["/Users/ted/Desktop/jbook/packages/local-client/node_modules/prismjs/components/prism-graphql.js"],"names":["Prism","languages","graphql","pattern","greedy","alias","inside","lookbehind","markdown","hooks","add","afterTokenizeGraphql","env","language","validTokens","tokens","filter","token","type","currentIndex","getToken","offset","isTokenType","types","i","length","findClosingBracket","open","close","stackHeight","content","test","addAlias","aliases","Array","isArray","push","startToken","inputVariables","definitionEnd","t","mutationEnd","varToken","indexOf"],"mappings":"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","file":"x","sourcesContent":["Prism.languages.graphql = {\n\t'comment': /#.*/,\n\t'description': {\n\t\tpattern: /(?:\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")(?=\\s*[a-z_])/i,\n\t\tgreedy: true,\n\t\talias: 'string',\n\t\tinside: {\n\t\t\t'language-markdown': {\n\t\t\t\tpattern: /(^\"(?:\"\")?)(?!\\1)[\\s\\S]+(?=\\1$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: Prism.languages.markdown\n\t\t\t}\n\t\t}\n\t},\n\t'string': {\n\t\tpattern: /\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/,\n\t\tgreedy: true\n\t},\n\t'number': /(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n\t'boolean': /\\b(?:true|false)\\b/,\n\t'variable': /\\$[a-z_]\\w*/i,\n\t'directive': {\n\t\tpattern: /@[a-z_]\\w*/i,\n\t\talias: 'function'\n\t},\n\t'attr-name': {\n\t\tpattern: /[a-z_]\\w*(?=\\s*(?:\\((?:[^()\"]|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")*\\))?:)/i,\n\t\tgreedy: true\n\t},\n\t'atom-input': {\n\t\tpattern: /[A-Z]\\w*Input(?=!?.*$)/m,\n\t\talias: 'class-name'\n\t},\n\t'scalar': /\\b(?:Boolean|Float|ID|Int|String)\\b/,\n\t'constant': /\\b[A-Z][A-Z_\\d]*\\b/,\n\t'class-name': {\n\t\tpattern: /(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,\n\t\tlookbehind: true\n\t},\n\t'fragment': {\n\t\tpattern: /(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))[a-zA-Z_]\\w*/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'definition-mutation': {\n\t\tpattern: /(\\bmutation\\s+)[a-zA-Z_]\\w*/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'definition-query': {\n\t\tpattern: /(\\bquery\\s+)[a-zA-Z_]\\w*/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'keyword': /\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,\n\t'operator': /[!=|&]|\\.{3}/,\n\t'property-query': /\\w+(?=\\s*\\()/,\n\t'object': /\\w+(?=\\s*\\{)/,\n\t'punctuation': /[!(){}\\[\\]:=,]/,\n\t'property': /\\w+/\n};\n\nPrism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {\n\tif (env.language !== 'graphql') {\n\t\treturn;\n\t}\n\n\t/**\n\t * get the graphql token stream that we want to customize\n\t *\n\t * @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\t * @type {Token[]}\n\t */\n\tvar validTokens = env.tokens.filter(function (token) {\n\t\treturn typeof token !== 'string' && token.type !== 'comment' && token.type !== 'scalar';\n\t});\n\n\tvar currentIndex = 0;\n\n\t/**\n\t * Returns whether the token relative to the current index has the given type.\n\t *\n\t * @param {number} offset\n\t * @returns {Token | undefined}\n\t */\n\tfunction getToken(offset) {\n\t\treturn validTokens[currentIndex + offset];\n\t}\n\n\t/**\n\t * Returns whether the token relative to the current index has the given type.\n\t *\n\t * @param {readonly string[]} types\n\t * @param {number} [offset=0]\n\t * @returns {boolean}\n\t */\n\tfunction isTokenType(types, offset) {\n\t\toffset = offset || 0;\n\t\tfor (var i = 0; i < types.length; i++) {\n\t\t\tvar token = getToken(i + offset);\n\t\t\tif (!token || token.type !== types[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns the index of the closing bracket to an opening bracket.\n\t *\n\t * It is assumed that `token[currentIndex - 1]` is an opening bracket.\n\t *\n\t * If no closing bracket could be found, `-1` will be returned.\n\t *\n\t * @param {RegExp} open\n\t * @param {RegExp} close\n\t * @returns {number}\n\t */\n\tfunction findClosingBracket(open, close) {\n\t\tvar stackHeight = 1;\n\n\t\tfor (var i = currentIndex; i < validTokens.length; i++) {\n\t\t\tvar token = validTokens[i];\n\t\t\tvar content = token.content;\n\n\t\t\tif (token.type === 'punctuation' && typeof content === 'string') {\n\t\t\t\tif (open.test(content)) {\n\t\t\t\t\tstackHeight++;\n\t\t\t\t} else if (close.test(content)) {\n\t\t\t\t\tstackHeight--;\n\n\t\t\t\t\tif (stackHeight === 0) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Adds an alias to the given token.\n\t *\n\t * @param {Token} token\n\t * @param {string} alias\n\t * @returns {void}\n\t */\n\tfunction addAlias(token, alias) {\n\t\tvar aliases = token.alias;\n\t\tif (!aliases) {\n\t\t\ttoken.alias = aliases = [];\n\t\t} else if (!Array.isArray(aliases)) {\n\t\t\ttoken.alias = aliases = [aliases];\n\t\t}\n\t\taliases.push(alias);\n\t}\n\n\tfor (; currentIndex < validTokens.length;) {\n\t\tvar startToken = validTokens[currentIndex++];\n\n\t\t// add special aliases for mutation tokens\n\t\tif (startToken.type === 'keyword' && startToken.content === 'mutation') {\n\t\t\t// any array of the names of all input variables (if any)\n\t\t\tvar inputVariables = [];\n\n\t\t\tif (isTokenType(['definition-mutation', 'punctuation']) && getToken(1).content === '(') {\n\t\t\t\t// definition\n\n\t\t\t\tcurrentIndex += 2; // skip 'definition-mutation' and 'punctuation'\n\n\t\t\t\tvar definitionEnd = findClosingBracket(/^\\($/, /^\\)$/);\n\t\t\t\tif (definitionEnd === -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// find all input variables\n\t\t\t\tfor (; currentIndex < definitionEnd; currentIndex++) {\n\t\t\t\t\tvar t = getToken(0);\n\t\t\t\t\tif (t.type === 'variable') {\n\t\t\t\t\t\taddAlias(t, 'variable-input');\n\t\t\t\t\t\tinputVariables.push(t.content);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcurrentIndex = definitionEnd + 1;\n\t\t\t}\n\n\t\t\tif (isTokenType(['punctuation', 'property-query']) && getToken(0).content === '{') {\n\t\t\t\tcurrentIndex++; // skip opening bracket\n\n\t\t\t\taddAlias(getToken(0), 'property-mutation');\n\n\t\t\t\tif (inputVariables.length > 0) {\n\t\t\t\t\tvar mutationEnd = findClosingBracket(/^\\{$/, /^\\}$/);\n\t\t\t\t\tif (mutationEnd === -1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// give references to input variables a special alias\n\t\t\t\t\tfor (var i = currentIndex; i < mutationEnd; i++) {\n\t\t\t\t\t\tvar varToken = validTokens[i];\n\t\t\t\t\t\tif (varToken.type === 'variable' && inputVariables.indexOf(varToken.content) >= 0) {\n\t\t\t\t\t\t\taddAlias(varToken, 'variable-input');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n"]}}